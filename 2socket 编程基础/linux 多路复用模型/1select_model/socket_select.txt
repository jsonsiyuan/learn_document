/*socket客户端实现*/
 #include<stdio.h>
 #include<unistd.h>
 #include<stdlib.h>
 #include<string.h>
 #include<errno.h>
 #include<netinet/in.h>
 #include<sys/types.h>
 #include<sys/socket.h>
 #include<arpa/inet.h>
 #include<sys/select.h>
 
 #define MAXLINE 1024
 #define SERV_PORT 1987
 
 //输入是由stdin,接收是由server 发送过来的。
 void send_and_recv(int connfd)
 {
     int lens;
	 /*文件描述符0、1和2分别代表stdin、stdout和stderr*/
	 int stdinfd=0;
	 char send[MAXLINE];
	 char recv[MAXLINE];
	 fd_set rset;
	 int nread;
	 //获得输出和输入的最大值。
	 int maxfd=(stdinfd>connfd? stdinfd:connfd);
	 
	 FD_ZERO(&rset);
	 FD_SET(stdinfd，&rset);
	 FD_SET(connfd,&rset);
	 //每次都需要更新该数组
	 if(-1==select(maxfd+1,&rset,NULL,NULL,NULL))
	 {
		perror("select");
		exit(EXIT_FAILURE);
		
	 }
	 //如果连接口有信息
	 if(FD_ISSET(connfd,&rset))
	 {
	     memset(recv,0,sizeof(recv));
		 nread=read(connfd,recv,sizeof(recv));
		 if(0==nread)
		 {
		     printf("Disconnected with server\n");
			 return;
		 }
		 else if(-1==nread)
		 {
		     printf("Recv error ....\n");
		 }
		 else
		 {
		     printf("Client recv:%s\n",recv);
		 }
	 }
	 //如果标准输入有数据输入
	 if(FD_ISSET(stdinfd,&rset))
	 {
	     memset(send,0,seizeof(send));
		 if(lens=read(stdinfd,send,sizeof(send))<=0)
		 {
		     printf("End....\n");
			 exit(EXIT_FAILURE);
		 }
		 else
		 {
		     send[lens-1]='\0';
			 if(0==strcmp(send,"q"))
			 {
			     printf("Bye..\n");
				 return ;
			 }
			 printf("Client send :%s\n",send);
			 write(connfd,send,strlen(send));
		 }
	 }
 }
